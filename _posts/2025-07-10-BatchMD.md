---
title: BatchMD
description: >-
  An introduction to the functions in /BatchMD
authors: [pengxin, xin]
date: 2025-07-10 22:42:00 +0800
categories: [Tutorials, BatchMD]
tags: [BatchMD]
---

## NVE

(

`time_step`: `<class 'float'>`

`max_step`: `<class 'int'>`

`T_init`: `<class 'float'> = 298.15`

`output_file`: `str | None = None`

`output_structures_per_step`: `<class 'int'> = 1`

`device`: `str | torch.device = cpu`

`verbose`: `<class 'int'> = 2`

)


    Micro canonical ensemble (NVE) molecular dynamics.

    Parameters:
        time_step: float, time per step (ps).
        max_step: int, maximum steps.
        T_init: float, initial temperature, only to generate initial velocities of atoms by Maxwell-Boltzmann distribution. If V_init is given, T_init will be ignored.
        output_structures_per_step: int, output structures per output_structures_per_step steps.
        device: str|torch.device, device that program rum on.
        verbose: int, control the detailed degree of output information. 0 for silence, 1 for output Energy and Forces per step, 2 for output all structures.

    Methods:
        run: run BatchMD.

    

## run

(

`func`: `Any | torch.nn.modules.module.Module`

`X`: `<class 'torch.Tensor'>`

`Element_list`: `Union[List[List[str]], List[List[int]]]`

`V_init`: `torch.Tensor | None = None`

`grad_func`: `Any | torch.nn.modules.module.Module = None`

`func_args`: `Sequence = ()`

`func_kwargs`: `Optional[Dict] = None`

`grad_func_args`: `Sequence = ()`

`grad_func_kwargs`: `Optional[Dict] = None`

`is_grad_func_contain_y`: `<class 'bool'> = True`

`batch_indices`: `Union[List[int], Tuple[int, ...], torch.Tensor, numpy.ndarray, NoneType] = None`

`fixed_atom_tensor`: `Optional[torch.Tensor] = None`

`is_fix_mass_center`: `<class 'bool'> = False`

)



        Parameters:
            func: the main function of instantiated torch.nn.Module class.
            X: Tensor[n_batch, n_atom, 3], the atom coordinates that input to func. If a 2D X was given, the first dimension would be set to 1.
            Element_list: List[List[str | int]], the atomic type (element) corresponding to each row of each batch in X.
            V_init: the initial velocities of each atom. If None, a random velocity generated by Boltzmann distribution would be set.
            grad_func: user-defined function that grad_func(X, ...) returns the func's gradient at X. if None, grad_func(X, ...) = th.autograd.grad(func(X, ...), X).
            func_args: optional, other input of func.
            func_kwargs: optional, other input of func.
            grad_func_args: optional, other input of grad_func.
            grad_func_kwargs: optional, other input of grad_func.
            is_grad_func_contain_y: bool, if True, grad_func contains output of func followed by X i.e., grad = grad_func(X, y, ...), else grad = grad_func(X, ...)
            batch_indices: the split points for given X, Element_list & V_init, must be 1D integer array_like.
                the format of batch_indices is the same as `split_size_or_sections` in torch.split:
                batch_indices = (n1, n2, ..., nN) will split X, Element_list & V_init into N parts, and ith parts has ni atoms. sum(n1, ..., nN) = X.shape[1]
            fixed_atom_tensor: the indices of X that fixed.
            is_fix_mass_center: whether transition coordinates and velocities of atoms into the mass center.

        Returns:
            min func: Tensor(n_batch, ), the minimum of func.
            argmin func: Tensor(X.shape), the X corresponds to min func.

        

## NVT

(

`time_step`: `<class 'float'>`

`max_step`: `<class 'int'>`

`thermostat`: `Literal['Langevin', 'VR', 'Nose-Hoover', 'CSVR']`

`thermostat_config`: `Optional[Dict] = None`

`T_init`: `<class 'float'> = 298.15`

`output_file`: `str | None = None`

`output_structures_per_step`: `<class 'int'> = 1`

`device`: `str | torch.device = cpu`

`verbose`: `<class 'int'> = 2`

)


    Canonical ensemble (NVT) molecular dynamics.

    Parameters:
        time_step: float, time per step (ps).
        max_step: maxmimum steps.
        thermostat: str, the thermostat of NVT ensemble.
        thermostat_config: Dict|None, configs of thermostat. {'damping_coeff': float} for Langevin, {'time_const': float} for CSVR, {'virt_mass': float} for Nose-Hoover.
        T_init: initial temperature, only to generate initial velocities of atoms by Maxwell-Boltzmann distribution. If V_init is given, T_init will be ignored.
        output_structures_per_step: int, output structures per output_structures_per_step steps.
        device: device that the program rum on.
        verbose: control the detailed degree of output information. 0 for silence, 1 for output Energy and Forces per step, 2 for output all structures.

    Methods:
        run: run the NVT ensemble BatchMD.
    

## run

(

`func`: `Any | torch.nn.modules.module.Module`

`X`: `<class 'torch.Tensor'>`

`Element_list`: `Union[List[List[str]], List[List[int]]]`

`V_init`: `torch.Tensor | None = None`

`grad_func`: `Any | torch.nn.modules.module.Module = None`

`func_args`: `Sequence = ()`

`func_kwargs`: `Optional[Dict] = None`

`grad_func_args`: `Sequence = ()`

`grad_func_kwargs`: `Optional[Dict] = None`

`is_grad_func_contain_y`: `<class 'bool'> = True`

`batch_indices`: `Union[List[int], Tuple[int, ...], torch.Tensor, numpy.ndarray, NoneType] = None`

`fixed_atom_tensor`: `Optional[torch.Tensor] = None`

`is_fix_mass_center`: `<class 'bool'> = False`

)



        Parameters:
            func: the main function of instantiated torch.nn.Module class.
            X: Tensor[n_batch, n_atom, 3], the atom coordinates that input to func. If a 2D X was given, the first dimension would be set to 1.
            Element_list: List[List[str | int]], the atomic type (element) corresponding to each row of each batch in X.
            V_init: the initial velocities of each atom. If None, a random velocity generated by Boltzmann distribution would be set.
            grad_func: user-defined function that grad_func(X, ...) returns the func's gradient at X. if None, grad_func(X, ...) = th.autograd.grad(func(X, ...), X).
            func_args: optional, other input of func.
            func_kwargs: optional, other input of func.
            grad_func_args: optional, other input of grad_func.
            grad_func_kwargs: optional, other input of grad_func.
            is_grad_func_contain_y: bool, if True, grad_func contains output of func followed by X i.e., grad = grad_func(X, y, ...), else grad = grad_func(X, ...)
            batch_indices: the split points for given X, Element_list & V_init, must be 1D integer array_like.
                the format of batch_indices is the same as `split_size_or_sections` in torch.split:
                batch_indices = (n1, n2, ..., nN) will split X, Element_list & V_init into N parts, and ith parts has ni atoms. sum(n1, ..., nN) = X.shape[1]
            fixed_atom_tensor: the indices of X that fixed.
            is_fix_mass_center: whether transition coordinates and velocities of atoms into the mass center.

        Returns:
            min func: Tensor(n_batch, ), the minimum of func.
            argmin func: Tensor(X.shape), the X corresponds to min func.

        

## BiasedMD

(

`time_step`: `<class 'float'>`

`max_step`: `<class 'int'>`

`thermostat`: `Literal['Langevin', 'VR', 'Nose-Hoover', 'CSVR']`

`thermostat_config`: `Optional[Dict] = None`

`T_init`: `<class 'float'> = 298.15`

`output_file`: `str | None = None`

`output_structures_per_step`: `<class 'int'> = 1`

`device`: `str | torch.device = cpu`

`verbose`: `<class 'int'> = 2`

)


    Performing MD with given external-biased potentials.
    

## run

(

`func`: `Any | torch.nn.modules.module.Module`

`X`: `<class 'torch.Tensor'>`

`Element_list`: `Union[List[List[str]], List[List[int]]]`

`V_init`: `torch.Tensor | None = None`

`grad_func`: `Any | torch.nn.modules.module.Module = None`

`func_args`: `Union[Tuple, List] = ()`

`func_kwargs`: `Optional[Dict] = None`

`grad_func_args`: `Union[Tuple, List] = ()`

`grad_func_kwargs`: `Optional[Dict] = None`

`is_grad_func_contain_y`: `<class 'bool'> = True`

`batch_indices`: `Union[List[int], Tuple[int, ...], torch.Tensor, numpy.ndarray, NoneType] = None`

`fixed_atom_tensor`: `Optional[torch.Tensor] = None`

`is_fix_mass_center`: `<class 'bool'> = False`

)



        Args:
            func:
            X:
            Element_list:
            V_init:
            grad_func:
            func_args:
            func_kwargs:
            grad_func_args:
            grad_func_kwargs:
            is_grad_func_contain_y:
            batch_indices:
            fixed_atom_tensor:
            is_fix_mass_center:

        Returns:

        

## set_external_potential

(

`potential_func`: `Callable`

`potential_grad_func`: `Optional[Callable] = None`

`func_args`: `Tuple = ()`

`func_kwargs`: `Optional[Dict] = None`

`grad_func_args`: `Tuple = ()`

`grad_func_kwargs`: `Optional[Dict] = None`

`is_grad_contain_y`: `<class 'bool'> = True`

)


        Set the external potential function.
        Args:
            potential_func: the function of external potential
            potential_grad_func: the gradient of external potential. if None, torch.autograd is applied.
            func_args: arguments of `potential_func`
            func_kwargs: key words arguments of `potential_func`
            grad_func_args: arguments of `potential_grad_func`
            grad_func_kwargs: key words arguments of `potential_grad_func`
            is_grad_contain_y: whether `potential_grad_func` needs dependent variable y as input. if True, potential_grad_func = g(X, y), else g(X)
            #is_dynamic: whether potential function containing time as independent variables. if True, potential_func = f(X, t), else f(X).

        Returns:
